# HG changeset patch
# Parent b2f1cbecf04b834227810ce8cfd44ba10599736a

diff --git a/services/Makefile.in b/services/Makefile.in
--- a/services/Makefile.in
+++ b/services/Makefile.in
@@ -38,12 +38,12 @@
 DEPTH     = ..
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 ifdef MOZ_SERVICES_SYNC
-PARALLEL_DIRS += common crypto sync
+PARALLEL_DIRS += aitc common crypto sync
 endif
 
 include $(topsrcdir)/config/rules.mk
diff --git a/services/aitc/AitcComponents.manifest b/services/aitc/AitcComponents.manifest
new file mode 100644
--- /dev/null
+++ b/services/aitc/AitcComponents.manifest
@@ -0,0 +1,6 @@
+# service.js
+component {a3d387ca-fd26-44ca-93be-adb5fda5a78d} service.js
+contract @mozilla.org/services/aitc;1 {a3d387ca-fd26-44ca-93be-adb5fda5a78d}
+category app-startup AitcService service,@mozilla.org/services/aitc;1
+# Register resource aliases
+resource services-aitc resource:///modules/services-aitc/
diff --git a/services/aitc/Makefile.in b/services/aitc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/services/aitc/Makefile.in
@@ -0,0 +1,24 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH     = ../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+EXTRA_COMPONENTS = \
+  AitcComponents.manifest \
+  service.js \
+  $(NULL)
+
+PREF_JS_EXPORTS = $(srcdir)/services-aitc.js
+
+libs::
+	$(NSINSTALL) $(srcdir)/modules/* $(FINAL_TARGET)/modules/services-aitc
+
+TEST_DIRS += tests
+
+include $(topsrcdir)/config/rules.mk
diff --git a/services/aitc/modules/client.js b/services/aitc/modules/client.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/modules/client.js
@@ -0,0 +1,287 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ['AitcClient'];
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+
+Cu.import("resource://services-common/rest.js");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+
+const PREFS = new Preferences("services.aitc.client.");
+
+function AitcClient(token) {
+  this.uri = token.endpoint.replace(/\/+$/, "");
+  this.token = {id: token.id, key: token.key};
+
+  this._log = Log4Moz.repository.getLogger("Services.AITC.Client");
+  this._log.level = Log4Moz.Level[PREFS.get("log.level")];
+
+  this._backoff = false;
+  if (PREFS.get("backoff", 0)) {
+    this._backoff = true;
+  }
+
+  this._appsLastModified = null;
+  this._log.info("Client initialized with token endpoint: " + this.uri);
+}
+AitcClient.prototype = {
+  _requiredLocalKeys: [
+    "origin", "receipts", "manifestURL", "installOrigin"
+  ],
+  _requiredRemoteKeys: [
+    "origin", "receipts", "manifestPath", "installOrigin",
+    "installedAt", "modifiedAt"
+  ],
+
+  /**
+   * Initiates an update of a newly installed app to the AITC server. Call this
+   * when an application is installed locally.
+   *
+   * @param app
+   *        (Object) The app record of the application that was just installed.
+   */
+  remoteInstall: function remoteInstall(app, cb) {
+    if (!cb) {
+      throw new Error("remoteInstall called without callback");
+    }
+
+    this._putApp(this._makeRemoteApp(app), cb);
+  },
+
+  /**
+   * Initiates an update of an uinstalled app to the AITC server. Call this
+   * when an application is uninstalled locally.
+   *
+   * @param app
+   *        (Object) The app record of the application that was uninstalled.
+   */
+  remoteUninstall: function remoteUninstall(app, cb) {
+    if (!cb) {
+      throw new Error("remoteUninstall called without callback");
+    }
+
+    let record = this._makeRemoteApp(app);
+    record.deleted = true;
+    this._putApp(record, cb);
+  },
+
+  /**
+   * Fetch remote apps from server with GET.
+   */
+  getApps: function getApps(cb) {
+    if (!cb) {
+      throw new Error("getApps called but no callback provided");
+    }
+
+    if (!this._checkBackoff()) {
+      cb(null, null);
+      return;
+    }
+
+    let uri = this.uri + "/apps/?full=1";
+    let req = new TokenAuthenticatedRESTRequest(uri, this.token);
+    if (this._appsLastModified) {
+      req.setHeader("x-if-modified-since", this._appsLastModified);
+    }
+
+    let self = this;
+    req.get(function(error) {
+      if (error) {
+        self._log.error("getApps request error " + error);
+        cb(error, null);
+        return;
+      }
+
+      // Set X-Backoff or Retry-After, if needed
+      self._setBackoff(req);
+      
+      // Process response
+      if (req.response.status == 304) {
+        self._log.info("getApps returned 304");
+        cb(null, null);
+        return;
+      }
+      if (req.response.status != 200) {
+        self._error(req);
+        cb(new Error("Unexpected error with getApps"), null);
+        return;
+      }
+
+      try {
+        let tmp = JSON.parse(req.response.body);
+        self._log.info("getApps succeeded and got " + tmp.length + " apps");
+        cb(null, tmp["apps"]);
+        // Don't update lastModified until we know cb succeeded.
+        self._appsLastModified = parseInt(req.response.headers['x-timestamp']);
+      } catch (e) {
+        self._log.error("Exception in getApps " + e);
+      }
+    });
+  },
+
+  /**
+   * Change a given app record to match what the server expects.
+   * Change manifestURL to manifestPath, and trim out manifests since we 
+   * don't store them on the server.
+   */
+  _makeRemoteApp: function _makeRemoteApp(app) {
+    for each (let key in this.requiredLocalKeys) {
+      if (!app.key) {
+        throw new Error("Local app missing key " + key);
+      }
+    }
+
+    let record = {
+      origin:        app.origin,
+      receipts:      app.receipts,
+      manifestPath:  app.manifestURL,
+      installOrigin: app.installOrigin
+    };
+    if ("modifiedAt" in app) {
+      record.modifiedAt = app.modifiedAt;
+    }
+    if ("installedAt" in app) {
+      record.installedAt = app.installedAt;
+    }
+    return record;
+  },
+
+  /**
+   * Change a given app record received from the server to match what the local
+   * registry expects. (Inverse of _makeRemoteApp)
+   */
+  _makeLocalApp: function _makeLocalApp(app) {
+    for each (let key in this._requiredRemoteKeys) {
+      if (!app.key) {
+        throw new Error("Remote app missing key " + key);
+      }
+    }
+
+    let record = {
+      origin:         app.origin,
+      installOrigin:  app.installOrigin,
+      installedAt:    app.installedAt,
+      modifiedAt:     app.modifiedAt,
+      manifestURL:    app.manifestPath,
+      receipts:       app.receipts
+    };
+    if ("deleted" in app) {
+      record.deleted = app.deleted;
+    }
+    return record;
+  },
+
+  /**
+   * Try PUT for an app on the server and determine if we should retry
+   * if it fails.
+   */
+  _putApp: function _putApp(app, cb) {
+    if (!this._checkBackoff) {
+      // PUT requests may qualify as the "minimum number of additional requests
+      // required to maintain consistency of their stored data". However, it's
+      // better to keep server load low, even if it means user's apps won't
+      // reach their other devices during the early days of AITC. We should
+      // revisit this when we have a better of idea of server load curves.
+      err = new Error("X-Backoff in effect, aborting PUT");
+      err.removeFromQueue = false;
+      cb(err, null);
+      return;
+    }
+
+    let uri = this._makeAppURI(app.record.origin);
+    let req = new TokenAuthenticatedRESTRequest(uri, this.token);
+    if (app.modified) {
+      req.setHeader("X-If-Unmodified-Since", app.modified);
+    }
+
+    req.put(JSON.stringify(appRec), function _tryPuttingAppFinished(error) {
+      if (error) {
+        self._log.error("_putApp request error " + error);
+        cb(error, null);
+        return;
+      }
+
+      self._setBackoff(req);
+
+      let err = null;
+      switch (req.response.status) {
+        case 201:
+        case 204:
+          self._log.info("_putApp succeeded");
+          cb(null, true);
+          break;
+
+        case 400:
+        case 412:
+        case 413:
+          let msg = "_putApp returned: " + req.response.status;
+          self._log.warn(msg);
+          err = new Error(msg);
+          err.removeFromQueue = true;
+          cb(err, null);
+          break;
+
+        default:
+          self._error(req);
+          err = new Error("Unexpected error with _putApp");
+          err.removeFromQueue = false;
+          cb(err, null);
+          break;
+      }
+    });
+  },
+
+  /**
+   * Utility methods.
+   */
+  _error: function _error(req) {
+    this._log.error("Catch-all error for request for: " + 
+      req.uri.asciiSpec + req.response.status + " with: " + req.response.body);
+  },
+
+  _makeAppURI: function _makeAppURI(origin) {
+    let part = CryptoUtils.sha1Base64URLFriendly(origin);
+    return this.uri + "/apps/" + part;
+  },
+
+  // Before making a request, check if we are allowed to.
+  _checkBackoff: function _checkBackoff() {
+    if (!this._backoff) {
+      return true;
+    }
+
+    let time = new Date().getTime();
+    let lastReq = PREFS.get("lastReq", 0);
+    let backoff = PREFS.get("backoff", 0);
+
+    if (lastReq + (backoff * 1000) < time) {
+      this._log.warn("X-Backoff is " + backoff + ", not making request");
+      return false;
+    }
+
+    this._backoff = false;
+    PREFS.put("backoff", 0);
+    return true;
+  },
+
+  // Set values from X-Backoff and Retry-After headers, if present
+  _setBackoff: function _setBackoff(req) {
+    let backoff = 0;
+    PREFS.put("lastReq", new Date().getTime());
+    if (req.response.headers['x-backoff']) {
+      backoff = req.response.headers['x-backoff'];
+    }
+    if (req.response.headers['retry-after']) {
+      backoff = req.response.headers['retry-after'];
+    }
+    if (backoff) {
+      self._backoff = true;
+      PREFS.put("backoff", backoff);
+    }
+  },
+};
\ No newline at end of file
diff --git a/services/aitc/modules/main.js b/services/aitc/modules/main.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/modules/main.js
@@ -0,0 +1,132 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["Aitc"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/Webapps.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+Cu.import("resource://services-aitc/manager.js");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+
+function AitcSvc() {
+  this._log = Log4Moz.repository.getLogger("Service.AITC");
+  this._log.level = Log4Moz.Level[Preferences.get(
+    "services.aitc.log.logger.service"
+  )];
+  let dapp = new Log4Moz.DumpAppender();
+  dapp.level = Log4Moz.Level["Info"];
+  this._log.addAppender(dapp);
+  this._log.info("Loading AitC");
+  this._manager = new AitcManager();
+}
+AitcSvc.prototype = {
+  get DASHBOARD() {
+    return Preferences.get("services.aitc.dashboard.url");
+  },
+
+  // The goal of the init function is to be ready to activate the AITC
+  // client whenever the user is looking at the dashboard.
+  init: function init() {
+    let self = this;
+
+    // This is called iff the user is currently looking the dashboard.
+    function dashboardLoaded(browser) {
+      self._log.info("Dashboard was accessed");
+      self._manager.userOnDashboard(browser.contentWindow);
+    }
+    // This is called when the user's attention is elsewhere.
+    function dashboardUnloaded() {
+      self._log.info("Dashboard closed or in background");
+      self._manager.userOffDashboard();
+    }
+
+    // Called when a URI is loaded in any tab. We have to listen for this
+    // because tabSelected is not called if I open a new tab which loads
+    // about:home and then navigate to the dashboard, or navigation via
+    // links on the currently open tab.
+    let listener = {
+      onLocationChange: function onLocationChange(browser, progress, req, location, flags) {
+        let win = Services.wm.getMostRecentWindow("navigator:browser");
+        if (win.gBrowser.selectedBrowser == browser) {
+          let uri = location.spec.substring(0, self.DASHBOARD.length);
+          if (uri == self.DASHBOARD) {
+            dashboardLoaded(browser);
+          }
+        }
+      }
+    };
+    // Called when the current tab selection changes.
+    function tabSelected(event) {
+      let browser = event.target.linkedBrowser;
+      let uri = browser.currentURI.spec.substring(0, self.DASHBOARD.length);
+      if (uri == self.DASHBOARD) {
+        dashboardLoaded(browser);
+      } else {
+        dashboardUnloaded();
+      }
+    }
+
+    // Add listeners for all windows opened in the future.
+    function winWatcher(subject, topic) {
+      if (topic != "domwindowopened") return;
+      subject.addEventListener("load", function winWatcherLoad() {
+        subject.removeEventListener("load", winWatcherLoad, false);
+        let doc = subject.document.documentElement;
+        if (doc.getAttribute("windowtype") == "navigator:browser") {
+          let browser = subject.gBrowser;
+          browser.addTabsProgressListener(listener);
+          browser.tabContainer.addEventListener("TabSelect", tabSelected);
+        }
+      }, false);
+    }
+    Services.ww.registerNotification(winWatcher);
+
+    // Add listeners for all current open windows.
+    let enumerator = Services.wm.getEnumerator("navigator:browser");
+    while (enumerator.hasMoreElements()) {
+      let browser = enumerator.getNext().gBrowser;
+      browser.addTabsProgressListener(listener);
+      browser.tabContainer.addEventListener("TabSelect", tabSelected);
+
+      // Also check the currently open URI.
+      let uri = browser.contentDocument.location.toString().substring(
+        0, self.DASHBOARD.length
+      );
+      if (uri == self.DASHBOARD) {
+        dashboardLoaded(browser);
+      }
+    }
+
+    // Add listeners for app installs/uninstall.
+    Services.obs.addObserver(this, "webapps-sync-install", false);
+    Services.obs.addObserver(this, "webapps-sync-uninstall", false);
+  },
+
+  observe: function(aSubject, aTopic, aData) {
+    let app;
+    switch (aTopic) {
+      case "webapps-sync-install":
+        app = JSON.parse(aData);
+        this._log.info(app.origin + " was installed, initiating PUT");
+        this._manager.appEvent("install", app);
+        break;
+      case "webapps-sync-uninstall":
+        app = JSON.parse(aData);
+        this._log.info(app.origin + " was uninstalled, initiating PUT");
+        this._manager.appEvent("uninstall", app);
+        break;
+    }
+  }
+};
+
+XPCOMUtils.defineLazyGetter(this, "Aitc", function() {
+  return new AitcSvc();
+});
diff --git a/services/aitc/modules/manager.js b/services/aitc/modules/manager.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/modules/manager.js
@@ -0,0 +1,378 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["AitcManager"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/Webapps.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/FileUtils.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/identity/browserid.js");
+
+Cu.import("resource://services-aitc/client.js");
+Cu.import("resource://services-aitc/storage.js");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-common/tokenserverclient.js");
+
+const PREFS = new Preferences("services.aitc.")
+function AitcManager() {
+  this._client = null;
+  this._getTimer = null;
+  this._putTimer = null;
+
+  this._pending = new AitcQueue("webapps-pending.json");
+
+  this._log = Log4Moz.repository.getLogger("Service.AITC.Manager");
+  this._log.level = Log4Moz.Level[Preferences.get("manager.log.level")];
+  let dapp = new Log4Moz.DumpAppender();
+  dapp.level = Log4Moz.Level["Info"];
+  this._log.addAppender(dapp);
+}
+AitcManager.prototype = {
+  get MARKETPLACE() {
+    return PREFS.get("marketplace.url");
+  },
+
+  get TOKEN_SERVER() {
+    return Preferences.get("tokenServer.url");
+  },
+
+  /**
+   * Local app was just installed or uninstalled, ask client to PUT if user
+   * is logged in.
+   */
+  appEvent: function appEvent(type, app) {
+    // Add this to the equeue.
+    let self = this;
+    let obj = {type: type, app: app, retries: 0, lastTime: 0};
+    this._pending.enqueue(app, function _enqueued(err, rec) {
+      if (err) {
+        self._log.error("Could not add " + type + " " + app + " to queue");
+        return;
+      }
+
+      // If we already have a client (i.e. user is logged in), attempt to PUT.
+      if (self._client) {
+        self._processQueue();
+        return;
+      }
+
+      // If not, try a silent client creation.
+      let self = this;
+      this._makeClient(function(err, client) {
+        if (!err && client) {
+          self._client = client;
+          self._processQueue();
+        }
+        // If user is not logged in, we'll just have to try later.
+      });
+    });
+  },
+
+  /**
+   * User is looking at dashboard. Start polling, but if user isn't logged in,
+   * prompt for them to login via a dialog.
+   */
+  userOnDashboard: function userOnDashboard(win) {
+    if (this._client) {
+      this._startPoll();
+      return;
+    }
+
+    let self = this;
+    this._makeClient(function(err, client) {
+      if (err) {
+        // XXX: Surface this error the user, somehow?
+        self._log.error("Client not created at Dashboard");
+        return;
+      }
+      self._client = client;
+      self._startPoll();
+    }, true, win);
+  },
+
+  /**
+   * User is not on the dashboard, we may stop polling (though PUTs will
+   * still continue to be tried).
+   */
+  userOffDashboard: function userOffDashboard() {
+    if (this._client) {
+      this._stopPoll();
+      return;
+    }
+  },
+
+  /**
+   * Poll the AITC server for any changes and process them. Call this whenever
+   * the user is actively looking at the apps dashboard. It is safe to call
+   * this function multiple times.
+   */
+  _startPoll: function _startPoll() {
+    if (!this._client) {
+      throw new Error("_startPoll called without client");
+    }
+    if (this._getTimer) {
+      return;
+    }
+
+    // Create timer for GETs.
+    this._getTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+    let self = this;
+    let event = {
+      notify: function notify(timer) {
+        self._checkServer();
+      }
+    };
+
+    // Check if there are any PUTs pending first.
+    if (this._pending.length && !this._putTimer) {
+      // There are pending PUTs and no timer, so let's process them.
+      this._processQueue();
+    } else {
+      // Do one GET check right now.
+      this._checkServer();
+    }
+
+    // Start the timer for GETs. In case there were pending PUTs, _checkServer
+    // will automatically abort, and we'll retry after getFreq.
+    this._getTimer.initWithCallback(
+      event, PREFS.get("manager.getFreq", Ci.nsITimer.TYPE_REPEATING_SLACK
+    );    
+  },
+
+  /**
+   * Stop polling for changes. Call this as soon as the user
+   * isn't looking at the apps dashboard anymore. It is safe to call
+   * this function even if runPeriodically() wasn't called before.
+   */
+  _stopPoll: function _stopPoll() {
+    if (!this._getTimer) {
+      return;
+    }
+    this._getTimer.cancel();
+    this._getTimer = null;
+  },
+
+  /**
+   * Do a GET check on the server to see if we have any new apps. Abort if
+   * there are pending PUTs. If we GET some apps, send to storage for
+   * further processing.
+   */
+  _checkServer: function _checkServer() {
+    if (!this._client) {
+      throw new Error("_checkServer called without a client");
+    }
+
+    if (this._pending.length) {
+      this._log.warn("_checkServer aborted because of pending PUTs");
+      return;
+    }
+
+    // Do a GET
+    this._client.getApps(function gotApps(err, apps) {
+      if (err) {
+        // Error was logged in client.
+        return;
+      }
+      if (!app) {
+        // No changes, got 304.
+        return;
+      }
+
+      // Send list of remote apps to storage to apply locally
+      AitcStorage.processApps(apps, function processedApps() {
+        this._log.info("processApps completed successfully, changes applied");
+      });
+    });
+  },
+
+  /**
+   * Go through list of apps to PUT and attempt each one. If we fail, try
+   * again in PUT_FREQ.
+   */
+  _processQueue: function _processPutQueue() {
+    if (!this._client) {
+      throw new Error("_processPutQueue called without a client");
+    }
+
+    if (!this._pending.length) {
+      this._log.info("There are no pending items, _processQueue closing");
+      if (this._putTimer) {
+        this._putTimer.clear();
+      }
+      return;
+    }
+
+    if (this._putInProgress) {
+      // The network request sent out as a result to the last call to
+      // _processPutQueue still isn't done. A timer is created they all
+      // finish to make sure this function is called again if neccessary.
+      return;
+    }
+
+    let self = this;
+    this._putInProgress = true;
+    let record = this._pending.peek();
+
+    function _clientCallback(err, done) {
+      // Send to end of queue if unsuccessful or err.removeFromQueue is false.
+      if (err && !err.removeFromQueue) {
+        // Update retries and time
+        record.retries += 1;
+        record.lastTime = new Date().getTime();
+
+        // Add updated record to the end of the queue.
+        self._pending.enqueue(record, function(err, done) {
+          if (err) {
+            self._log.error("enqueue failed " + err);
+            _reschedule();
+            return;
+          }
+          // If record was successfully added, remove old record.
+          self._pending.dequeue(function(err, done) {
+            if (err) {
+              self._log.error("dequeue failed " + err);
+            }
+            _reschedule();
+            return;
+          });
+        });
+        return;
+      }
+
+      // If succeeded or client told us to remove from queue
+      if (err.removeFromQueue || done) {
+        self._pending.dequeue(function(err, done) {
+          if (err) {
+            self._log.error("queue dequeue failed " + e);
+          }
+          _reschedule();
+        });
+        return;
+      }
+    }
+
+    function _reschedule() {
+      // If any apps remain in the queue, try again after putFreq.
+      if (self._pending.length) {
+        CommonUtils.namedTimer(
+          self._processQueue, PREFS.get("manager.putFreq"), self, "_putTimer"
+        );
+      }
+    }
+
+    switch (record.type) {
+      case "install":
+        this._client.remoteInstall(record.app, _clientCallback);
+        break;
+      case "uninstall":
+        this._client.remoteUninstall(record.app, _clientCallback);
+        break;
+      default:
+        this._log.warn(
+          "Unrecognized type " + record.type + " in queue, removing"
+        );
+        this._pending.dequeue(_clientCallback);
+    }
+  },
+
+  /* Obtain a token from Sagrada token server, given a BrowserID assertion
+   * cb(err, token) will be invoked on success or failure.
+   */
+  _getToken: function _getToken(assertion, cb) {
+    let url = this.TOKEN_SERVER + "/1.0/aitc/1.0";
+    let client = new TokenServerClient();
+
+    let self = this;
+    this._log.info("Obtaining token from " + url);
+    client.getTokenFromBrowserIDAssertion(url, assertion, function(err, tok) {
+      if (!err) {
+        self._log.info("Got token from server: " + JSON.stringify(tok));
+        cb(null, tok);
+        return;
+      }
+
+      if (!err.response) {
+        let msg = "Error while fetching token " + err.message;
+        self._log.error(msg);
+        cb(new Error(msg), null);
+        return;
+      }
+      if (!err.response.success) {
+        let msg = "Error while fetching token (non-200) " + err.message;
+        self._log.error(msg);
+        cb(new Error(msg), null);
+        return;
+      }
+
+      let msg = "Unknown error while fetching token " + err.message;
+      self._log.error(msg);
+      cb(new Error(msg), null);
+    });
+  },
+
+  /* To start the AitcClient we need a token, for which we need a BrowserID
+   * assertion. If login is true, makeClient will ask the user to login in
+   * the context of win. cb is called with (err, client).
+   */
+  _makeClient: function makeClient(cb, login, win) {
+    if (!cb) {
+      throw new Error("makeClient called without callback");
+    }
+    if (login && !win) {
+      throw new Error("makeClient called with login as true but no win");
+    }
+
+    if (this._client) {
+      let msg = "Client already exists, not creating";
+      self._log.info(msg);
+      cb(new Error(msg), null);
+      return;
+    }
+
+    let self = this;
+    function processAssertion(val) {
+      self._log.info("Got assertion from BrowserID, creating token");
+      self._getToken(val, function(err, token) {
+        if (err) {
+          self._log.error("Could not obtain token from token server " + err);
+          cb(err, null);
+          return;
+        }
+        cb(null, new AitcClient(token));
+      });
+    }
+    function gotSilentAssertion(err, val) {
+      self._log.info("gotSilentAssertion called");
+      if (err) {
+        // If we were asked to let the user login, do the popup method
+        if (login) {
+          self._log.info("Could not obtain silent assertion, retrying login");
+          BrowserID.getAssertion(function gotAssertion(err, val) {
+            if (err) {
+              self._log.error("Could not obtain assertion even with login");
+              cb(err, false);
+              return;
+            }
+            processAssertion(val);
+          }, {}, win);
+          return;
+        }
+        self._log.error("Could not obtain assertion in _makeClient");
+        cb(err, false);
+      } else {
+        processAssertion(val);
+      }
+    }
+
+    // Check if we can get assertion silently first
+    BrowserID.getAssertion(gotSilentAssertion, {sameEmailAs: this.MARKETPLACE});
+  },
+
+};
diff --git a/services/aitc/modules/storage.js b/services/aitc/modules/storage.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/modules/storage.js
@@ -0,0 +1,361 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["AitcStorage", "AitcQueue"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+
+Cu.import("resource://gre/modules/NetUtil.jsm");
+Cu.import("resource://gre/modules/Webapps.jsm");
+Cu.import("resource://gre/modules/FileUtils.jsm");
+
+Cu.import("resource://services-common/rest.js");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+
+/**
+ * Provides a file-backed queue. Currently used by manager.js as persistent
+ * storage to manage pending installs and uninstalls.
+ */
+function AitcQueue(filename) {
+  this._log = Log4Moz.repository.getLogger("Service.AITC.Storage");
+  this._log.level = Log4Moz.Level[Preferences.get(
+    "services.aitc.storage.log.level"
+  )];
+  let dapp = new Log4Moz.DumpAppender();
+  dapp.level = Log4Moz.Level["Info"];
+  this._log.addAppender(dapp);
+
+  this._queue = [];
+  this._writeLock = false;
+  this._file = FileUtils.getFile("ProfD", ["webapps", filename], true);
+
+  if (this._file.exists()) {
+    this._getFile(function _gotFile(data) {
+      this._queue = data;
+    });
+  }
+}
+AitcQueue.prototype = {
+  /**
+   * Add an object to the queue.
+   */
+  enqueue: function enqueue(obj, cb) {
+    if (!cb) {
+      throw new Error("enqueue called without callback");
+    }
+
+    this._queue.push(obj);
+    try {
+      this._putFile(function _enqueuePutFile() {
+        // Successful write.
+        cb(null, true);
+      });
+    } catch (e) {
+      // Write unsuccessful, don't add to queue.
+      this._queue.pop();
+      cb(new Error(e), false);
+    }
+  },
+
+  /**
+   * Remove the object at the head of the queue.
+   */
+  dequeue: function dequeue(cb) {
+    if (!cb) {
+      throw new Error("dequeue called without callback");
+    }
+    if (!this._queue.length) {
+      throw new Error("Queue is empty");
+    }
+
+    let obj = this._queue.shift();
+    try {
+      this._putFile(function _dequeuePutFile() {
+        // Successful write.
+        cb(null, true);
+      });
+    } catch (e) {
+      // Unsuccessful write, put back in queue.
+      this._queue.unshift(obj);
+      cb(new Error(e), false);
+    }
+  },
+
+  /**
+   * Return the object at the front of the queue without removing it.
+   */
+  peek: function peek(cb) {
+    if (!this._queue.length) {
+      throw new Error("Queue is empty");
+    }
+    return this._queue[0];
+  },
+
+  /**
+   * Find out the length of the queue.
+   */
+  length: function length(cb) {
+    return this._queue.length;
+  },
+
+  /**
+   * Get contents of cache file and parse it into an array. Will throw an
+   * exception if there is an error while reading the file.
+   */
+  _getFile: function _getFile(cb) {
+    let channel = NetUtil.newChannel(this._file);
+    channel.contentType = "application/json";
+    NetUtil.asyncFetch(channel, function _asyncFetched(stream, res) {
+      if (!Components.isSuccessCode(res)) {
+        Cu.reportError("Could not read from json file " + this._file.path);
+        if (cb) {
+          cb(null);
+        }
+        return;
+      }
+
+      let data = null;
+      try {
+        data = JSON.parse(
+          NetUtil.readInputStreamToString(stream, stream.available()) || ""
+        );
+        stream.close();
+        if (cb) {
+          cb(data);
+        }
+      } catch (e) {
+        Cu.reportError("Could not parse JSON " + e);
+        if (cb) {
+          cb(null);
+        }
+      }
+    });
+  },
+
+  /**
+   * Put an array into the cache file. Will throw an exception if there is
+   * an error while trying to write to the file.
+   */
+  _putFile: function _putFile(value, cb) {
+    if (this._writeLock) {
+      throw new Error("_putFile already in progress");
+    }
+
+    this._writeLock = true;
+    try {
+      let ostream = FileUtils.openSafeFileOutputStream(
+        this._file, FileUtils.MODE_CREATE // Create file if it doesn't exist
+      );
+
+      let converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"].
+                      createInstance(Ci.nsIScriptableUnicodeConverter);
+      converter.charset = "UTF-8";
+
+      // Asynchronously copy the data to the file.
+      let self = this;
+      let istream = converter.convertToInputStream(JSON.stringify(value));
+      NetUtil.asyncCopy(istream, ostream, function _asyncCopied() {
+        self._writeLock = false;
+        if (cb) {
+          cb();
+        }
+      });
+    } catch (e) {
+      this._writeLock = false;
+      throw e;
+    }
+  },
+};
+
+/**
+ * An interface to DOMApplicationRegistry, used by manager.js to process
+ * remote changes received and apply them to the local registry.
+ */
+function AitcStorage() {
+  this._log = Log4Moz.repository.getLogger("Service.AITC.Storage");
+  this._log.level = Log4Moz.Level[Preferences.get(
+    "services.aitc.log.logger.storage"
+  )];
+  let dapp = new Log4Moz.DumpAppender();
+  dapp.level = Log4Moz.Level["Info"];
+  this._log.addAppender(dapp);
+
+  this._file = FileUtils.getFile(
+    "ProfD", ["webapps", "webapps-pending.json"], true
+  );
+}
+AitcStorage.prototype = {
+  /**
+   * Determines what changes are to be made locally, given a list of
+   * remote apps.
+   *
+   * @param remoteApps
+   *        (Array)     An array of app records fetched from the AITC server.
+   *
+   * @param callback
+   *        (function)  A callback to be invoked when processing is finished.
+   */
+  processApps: function processApps(remoteApps, callback) {
+    let self = this;
+    this._log.info("Server check got " + remoteApps.length + "apps");
+
+    // Get the set of local apps, and then pass to _processApps.
+    // _processApps will check for the validity of remoteApps.
+    DOMApplicationRegistry.getAllWithoutManifests(
+      function _processAppsGotLocalApps(localApps) {
+        self._processApps(remoteApps, localApps, callback);
+      }
+    );
+  },
+
+  /**
+   * Take a list of remote and local apps and figured out what changes (if any)
+   * are to be made to the local DOMApplicationRegistry.
+   */
+  _processApps: function _processApps(remoteApps, lApps, callback) {
+    let toDelete = {};
+    let localApps = {};
+    
+    // Convert lApps to a dictionary of origin -> app (instead of id -> app).
+    for (let [id, app] in Iterator(localApps)) {
+      app.id = id;
+      toDelete[app.origin] = app;
+      localApps[app.origin] = app;
+    }
+
+
+    // Iterate over remote apps, and find out what changes we must apply.
+    let toInstall = [];
+    for each (let app in remoteApps) {
+      // Don't delete apps that are both local & remote.
+      let origin = app.origin;
+      delete toDelete[origin];
+
+      // If there is a remote app that isn't local or 
+      // if the remote app was installed later.
+      if ((!(origin in localApps)) ||
+           localApps[origin].installTime < app.installTime) {
+        
+        let id = localApps[origin].id || DOMApplicationRegistry.makeAppId();
+
+        // We should install this app locally
+        try {          
+          let record = {id: id, value: this._makeLocalApp(app)};
+          toInstall.push(record);
+        } catch (e) {
+          // App was an invalid record
+          this._log.error("A remote app was found to be invalid " + e);
+        }
+      }
+    }
+
+    // Uninstalls only need the ID & deleted flag.
+    let toUninstall = [];
+    for (let origin in toDelete) {
+      toUninstall.push({id: toDelete[origin].id, deleted: true});
+    }
+
+    // Apply installs & uninstalls.
+    this._applyUpdates(toInstall, toUninstall, callback);
+    return;
+  },
+
+  /**
+   * Applies a list of commands as determined by processApps locally.
+   */
+  _applyUpdates: function _applyUpdates(toInstall, toUninstall, callback) {
+    let finalCommands = [];
+    let toUpdate = toInstall.length;
+
+    let self = this;
+    function onManifestsUpdated() {
+      finalCommands.push(toUninstall);
+      if (finalCommands.length) {
+        self._log.info(
+          "processUpdates finished fetching manifests, calling updateApps"
+        );
+        DOMApplicationRegistry.updateApps(finalCommands, callback);
+      } else {
+        self._log.info(
+          "processUpdates finished fetching, no finalCommands were found"
+        );
+        callback();
+      }
+    }
+
+    // Update manifests for all the new remote apps we have.
+    let done = 0;
+    for (let j = 0; j < toUpdate; j++) {
+      let app = toInstall[j];
+      let url = app.value.manifestURL;
+      if (url[0] == "/") {
+        url = app.value.origin + app.value.manifestURL;
+      }
+
+      this._log.info("Updating manifest " + url + "\n");
+      this._getManifest(url, function(err, manifest) {
+        if (!err) {
+          app.value.manifest = manifest;
+          finalCommands.push({id: app.id, value: app.value});
+          self._log.info(app.id + " was added to finalCommands");
+        } else {
+          self._log.debug("Couldn't fetch manifest at " + url + ": " + err);
+        }
+
+        // Not a big deal if we couldn't get a manifest, we will try to fetch
+        // it again in the next cycle. Carry on.
+        done += 1;
+        if (done == toUpdate) {
+          onManifestsUpdated();
+        }
+      });
+    }
+  },
+
+  /**
+   * Fetch a manifest from given URL. No retries are made on failure.
+   */
+  _getManifest: function _getManifest(url, callback)  {
+    let req = new RESTRequest(url);
+    req.get(function(error) {
+      if (error) {
+        callback(error, null);
+        return;
+      }
+      if (!req.response.success) {
+        callback(new Error("Non-200 while fetching manifest"), null);
+        return;
+      }
+
+      let err = null;
+      let manifest = null;
+      try {
+        manifest = JSON.parse(req.response.body);
+        if (!manifest.name) {
+          self._log.warn(
+            "_getManifest got invalid manifest: " + req.response.body
+          );
+          err = new Error("Invalid manifest fetched");
+          manifest = null;
+        }
+      } catch (e) {
+        self._log.warn(
+          "_getManifest got invalid JSON response: " + req.response.body
+        );
+        err = new Error("Invalid manifest fetched");
+        manifest = null;
+      }
+
+      callback(err, manifest);
+    });
+  },
+
+};
+
+XPCOMUtils.defineLazyGetter(this, "AitcStorage", function() {
+  return new AitcStorage();
+});
\ No newline at end of file
diff --git a/services/aitc/service.js b/services/aitc/service.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/service.js
@@ -0,0 +1,47 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/FileUtils.jsm");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-common/utils.js");
+
+function AitcService() {
+  this.wrappedJSObject = this;
+}
+AitcService.prototype = {
+  classID: Components.ID("{a3d387ca-fd26-44ca-93be-adb5fda5a78d}"),
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
+                                         Ci.nsISupportsWeakReference]),
+
+  observe: function observe(subject, topic, data) {
+    switch (topic) {
+      case "app-startup":
+        let os = Cc["@mozilla.org/observer-service;1"].
+                 getService(Ci.nsIObserverService);
+        os.addObserver(this, "final-ui-startup", true);
+        break;
+      case "final-ui-startup":
+        // Start AITC service after 2000ms, only if classic sync is off.
+        if (Preferences.get("services.sync.engine.apps", false)) {
+          return;
+        }
+
+        CommonUtils.namedTimer(function() {
+          Cu.import("resource://services-aitc/main.js");
+          Aitc.init();
+        }, 2000, this, "timer");
+        break;
+    }
+  }
+};
+
+const components = [AitcService];
+const NSGetFactory = XPCOMUtils.generateNSGetFactory(components);
\ No newline at end of file
diff --git a/services/aitc/services-aitc.js b/services/aitc/services-aitc.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/services-aitc.js
@@ -0,0 +1,15 @@
+pref("dom.mozApps.whitelist", "https://myapps.mozillalabs.com");
+
+pref("services.aitc.dashboard.url", "https://myapps.mozillalabs.com");
+pref("services.aitc.marketplace.url", "https://marketplace.mozilla.org");
+//pref("services.aitc.tokenServer.url", "http://dev-token.services.mozilla.com");
+//pref("services.aitc.tokenServer.url", "http://token2.reg.mtv1.dev.svc.mozilla.com");
+pref("services.aitc.tokenServer.url", "https://stage-token.services.mozilla.com");
+
+pref("services.aitc.manager.putFreq", 5000);
+pref("services.aitc.manager.getFreq", 30000);
+
+pref("services.aitc.client.log.level", "Debug");
+pref("services.aitc.manager.log.level", "Debug");
+pref("services.aitc.service.log.level", "Debug");
+pref("services.aitc.storage.log.level", "Debug");
diff --git a/services/aitc/tests/Makefile.in b/services/aitc/tests/Makefile.in
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/Makefile.in
@@ -0,0 +1,16 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH     = ../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+relativesrcdir = services/aitc/tests
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = test_services_aitc
+XPCSHELL_TESTS = unit
+
+include $(topsrcdir)/config/rules.mk
diff --git a/services/aitc/tests/unit/test_load_modules.js b/services/aitc/tests/unit/test_load_modules.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/unit/test_load_modules.js
@@ -0,0 +1,11 @@
+const modules = [
+  "main.js",
+  "client.js",
+];
+
+function run_test() {
+  for each (let m in modules) {
+    _("Attempting to load resource://services-aitc/" + m);
+    Cu.import("resource://services-aitc/" + m, {});
+  }
+}
diff --git a/services/aitc/tests/unit/xpcshell.ini b/services/aitc/tests/unit/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/unit/xpcshell.ini
@@ -0,0 +1,6 @@
+[DEFAULT]
+head =
+tail =
+
+# Ensure we can import everything.
+[test_load_modules.js]
diff --git a/testing/xpcshell/xpcshell.ini b/testing/xpcshell/xpcshell.ini
--- a/testing/xpcshell/xpcshell.ini
+++ b/testing/xpcshell/xpcshell.ini
@@ -63,16 +63,17 @@ skip-if = os == "android"
 [include:extensions/cookie/test/unit/xpcshell.ini]
 [include:storage/test/unit/xpcshell.ini]
 [include:rdf/tests/unit/xpcshell.ini]
 [include:gfx/tests/unit/xpcshell.ini]
 [include:widget/tests/unit/xpcshell.ini]
 [include:content/base/test/unit/xpcshell.ini]
 [include:content/test/unit/xpcshell.ini]
 [include:toolkit/components/url-classifier/tests/unit/xpcshell.ini]
+[include:services/aitc/tests/unit/xpcshell.ini]
 [include:services/common/tests/unit/xpcshell.ini]
 [include:services/crypto/tests/unit/xpcshell.ini]
 [include:services/crypto/components/tests/unit/xpcshell.ini]
 [include:services/sync/tests/unit/xpcshell.ini]
 # Bug 676978: tests hang on Android 
 skip-if = os == "android"
 [include:browser/components/dirprovider/tests/unit/xpcshell.ini]
 [include:browser/components/downloads/test/unit/xpcshell.ini]
