# HG changeset patch
# Parent b2b7011465acf146c99788ef2aa1603132ccac4c

diff --git a/services/Makefile.in b/services/Makefile.in
--- a/services/Makefile.in
+++ b/services/Makefile.in
@@ -38,12 +38,12 @@
 DEPTH     = ..
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 ifdef MOZ_SERVICES_SYNC
-PARALLEL_DIRS += common crypto sync
+PARALLEL_DIRS += aitc common crypto sync
 endif
 
 include $(topsrcdir)/config/rules.mk
diff --git a/services/aitc/AitcComponents.manifest b/services/aitc/AitcComponents.manifest
new file mode 100644
--- /dev/null
+++ b/services/aitc/AitcComponents.manifest
@@ -0,0 +1,6 @@
+# service.js
+component {a3d387ca-fd26-44ca-93be-adb5fda5a78d} service.js
+contract @mozilla.org/services/aitc;1 {a3d387ca-fd26-44ca-93be-adb5fda5a78d}
+category app-startup AitcService service,@mozilla.org/services/aitc;1
+# Register resource aliases
+resource services-aitc resource:///modules/services-aitc/
diff --git a/services/aitc/Makefile.in b/services/aitc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/services/aitc/Makefile.in
@@ -0,0 +1,24 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH     = ../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+EXTRA_COMPONENTS = \
+  AitcComponents.manifest \
+  service.js \
+  $(NULL)
+
+PREF_JS_EXPORTS = $(srcdir)/services-aitc.js
+
+libs::
+	$(NSINSTALL) $(srcdir)/modules/* $(FINAL_TARGET)/modules/services-aitc
+
+TEST_DIRS += tests
+
+include $(topsrcdir)/config/rules.mk
diff --git a/services/aitc/modules/client.js b/services/aitc/modules/client.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/modules/client.js
@@ -0,0 +1,492 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ['AitcClient'];
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+
+Cu.import("resource://gre/modules/Webapps.jsm");
+Cu.import("resource://services-common/rest.js");
+Cu.import("resource://services-common/utils.js");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+
+const PREFS = new Preferences("services.aitc.client.");
+
+// XXX: Inline these
+const GET_FREQ = PREFS.get("getFrequency");
+const PUT_FREQ = PREFS.get("putFrequency");
+
+function AitcClient(token, registry) {
+  this.uri = token.endpoint.replace(/\/+$/, "");
+  this.token = {id: token.id, key: token.key};
+
+  this.registry = registry || DOMApplicationRegistry;
+  this._log = Log4Moz.repository.getLogger("Services.AITC.Client");
+  this._log.level = Log4Moz.Level[PREFS.get("log.level")];
+
+  this.appsLastModified = null;
+  this._log.info("Client initialized with token endpoint: " + this.uri);
+}
+AitcClient.prototype = {
+  _putQueue: [],
+  _putTimer: null,
+  _putInProgress: false,
+
+  _requiredLocalKeys: [
+    "origin", "receipts", "manifestURL", "installOrigin"
+  ],
+  _requiredRemoteKeys: [
+    "origin", "receipts", "manifestPath", "installOrigin",
+    "installedAt", "modifiedAt"
+  ],
+
+  /**
+   * Initiates an update of a newly installed app to the AITC server. Call this
+   * when an application is installed locally.
+   *
+   * @param app
+   *        (Object) The app record of the application that was just installed.
+   */
+  remoteInstall: function remoteInstall(app, cb) {
+    this._putApp(this._makeRemoteApp(app), cb);
+  },
+
+  /**
+   * Initiates an update of an uinstalled app to the AITC server. Call this
+   * when an application is uninstalled locally.
+   *
+   * @param app
+   *        (Object) The app record of the application that was uninstalled.
+   */
+  remoteUninstall: function remoteUninstall(app, cb) {
+    let record = this._makeRemoteApp(app);
+    record.deleted = true;
+    this._putApp(record, cb);
+  },
+
+  /**
+   * Do a GET to see if there's anything new for us.
+   */
+  checkServer: function checkServer(cb) {
+    this._log.info("Starting scheduled server check");
+    
+    if (this._putQueue.length) {
+      let msg = "checkServer aborted due to PUTs in progress";
+      this._log.warn(msg);
+      throw new Error(msg);
+    }
+
+    this._getApps(cb, this._gotRemoteApps);
+  },
+
+  /**
+   * Utility methods.
+   */
+  _error: function _error(req) {
+    this._log.error("Catch-all error for request for: " + 
+      req.uri.asciiSpec + req.response.status + " with: " + req.response.body);
+  },
+
+  _makeAppURI: function _makeAppURI(origin) {
+    let part = CryptoUtils.sha1Base64URLFriendly(origin);
+    return this.uri + "/apps/" + part;
+  },
+
+  /**
+   * Change a given app record to match what the server expects.
+   * Change manifestURL to manifestPath, and trim out manifests since we 
+   * don't store them on the server.
+   */
+  _makeRemoteApp: function _makeRemoteApp(app) {
+    for each (let key in this.requiredLocalKeys) {
+      if (!app.key) {
+        throw new Error("Local app missing key " + key);
+      }
+    }
+
+    let record = {
+      origin:        app.origin,
+      receipts:      app.receipts,
+      manifestPath:  app.manifestURL,
+      installOrigin: app.installOrigin
+    };
+    if ("modifiedAt" in app) {
+      record.modifiedAt = app.modifiedAt;
+    }
+    if ("installedAt" in app) {
+      record.installedAt = app.installedAt;
+    }
+    return record;
+  },
+
+  /**
+   * Change a given app record received from the server to match what the local
+   * registry expects. (Inverse of _makeRemoteApp)
+   */
+  _makeLocalApp: function _makeLocalApp(app) {
+    for each (let key in this._requiredRemoteKeys) {
+      if (!app.key) {
+        throw new Error("Remote app missing key " + key);
+      }
+    }
+
+    let record = {
+      origin:         app.origin,
+      installOrigin:  app.installOrigin,
+      installedAt:    app.installedAt,
+      modifiedAt:     app.modifiedAt,
+      manifestURL:    app.manifestPath,
+      receipts:       app.receipts
+    };
+    if ("deleted" in app) {
+      record.deleted = app.deleted;
+    }
+    return record;
+  },
+
+  /**
+   * Receive remote apps, proceed to get local apps for processing.
+   */
+  _gotRemoteApps: function _gotRemoteApps(error, remoteApps) {
+    if (error) {
+      this._log.error("_getApps failed, will retry on next _checkServer");
+      return;
+    } else if (!remoteApps) {
+      this._log.info("_getApps got no new apps");
+      return;
+    }
+    
+    // _processApps checks for the validity of remoteApps.
+    let self = this;
+    this._log.info("Server check got " + remoteApps.length + "apps");
+    DOMApplicationRegistry.getAllWithoutManifests(
+      function _checkServerGotLocalApps(localApps) {
+        self._processApps(remoteApps, localApps, function _checkServerGotApps() {
+          self._log.info("processResponse completed and saved result");
+        });
+      }
+    );
+  },
+
+  /**
+   * Fetch remote apps from server.
+   */
+  _getApps: function _getApps(originalCb, cb) {
+    if (!cb) {
+      throw new Error("getApps called but no callback provided");
+    }
+
+    // If there's an unfinished PUT or a PUT that didn't succeed, just bail.
+    if (this._putQueue.length) {
+      this._log.warn("getApps called, but aborting due to outstanding PUT(s)!");
+      throw new Error("PUT(s) in progress, aborting GET!");
+    }
+
+    let req = new TokenAuthenticatedRESTRequest(this.uri + "/apps/?full=1",
+                                                this.token);
+    if (this.appsLastModified) {
+      req.setHeader("X-If-Modified-Since", this.appsLastModified);
+    }
+
+    let self = this;
+    req.get(function(error) {
+      if (error) {
+        self._log.error("_getApps request error " + error);
+        originalCb(error, null);
+        return;
+      }
+      if (req.response.status == 304) {
+        self._log.info("_getApps returned 304");
+        originalCb(null, null);
+        return;
+      }
+      if (req.response.status != 200) {
+        self._error(req);
+        originalCb(new Error("Unexpected error with getApps"), null);
+        return;
+      }
+
+      try {
+        let tmp = JSON.parse(req.response.body);
+        self._log.info("_getApps succeeded");
+        cb(null, tmp["apps"]);
+        // Don't update lastModified until we know cb succeeded.
+        self.appsLastModified = parseInt(req.response.headers['x-timestamp']);
+      } catch (e) {
+        self._log.error("Exception in _getApps " + e);
+      }
+    });
+  },
+
+  /**
+   * Add a PUT request to the queue.
+   */
+  _putApp: function _putApp(appRec, appLastModified) {
+    this._putQueue.push({
+      record:   appRec,
+      modified: appLastModified
+    });
+    this._processPutQueue();
+  },
+
+  /**
+   * Go through list of apps to PUT and attempt them. If we fail any, try
+   * them again PUT_FREQ.
+   * XXX: Sequentiall fire PUT requests from the queueu.
+   */
+  _processPutQueue: function _processPutQueue() {
+    if (this._putInProgress) {
+      // The network requests sent out as a result to the last call to
+      // _processPutQueue still aren't done. A timer is created they all
+      // finish to make sure this function is called again if neccessary.
+      return;
+    }
+
+    // If we're done with PUTs, stop timer
+    if (!this._putQueue.length) {
+      if (this._putTimer) {
+        this._putTimer.cancel();
+      }
+      return;
+    }
+    
+    // Copy current state of _putQueue.
+    let done = 0;
+    let unfinished = [];
+
+    // XXX: copy
+    let processNow = this._putQueue;
+
+    // We should empty out _putQueue now so we can know if there were any new
+    // apps added by calls to _putApp when we are finished. However, many
+    // places in the code check for _putQueue.length to know if there are
+    // outstanding PUTs, so we put a dummy value in it.
+    this._putQueue = ["DUMMY_APP"];
+
+    let self = this;
+    for (let i = 0; i < processNow.length; i++) {
+
+      let app = processNow[i];
+      this._tryPuttingApp(app, function(err, success) {
+        // Add back to queue if unsuccessful or err.removeFromQueue is false.
+        if (err && !err.removeFromQueue) {
+          unfinished.push(app);
+        }
+
+        // Check if this the last app in the queue to finish
+        done += 1
+        if (done == processNow.length) {
+          // Merge any apps that were added while we were busy and the
+          // unfinished ones (put new apps first).
+          self._putQueue = self._putQueue.concat(unfinished);
+
+          // Remove our DUMMY_APP.
+          self._putQueue.splice(0, 1);
+
+          // _processPutQueue is open for business again!
+          self._putInProgress = false;
+
+          // If any apps remain in the queue, try again in a bit.
+          if (self._putQueue.length) {
+            CommonUtils.namedTimer(
+              self._processPutQueue, PUT_FREQ, self, "_putTimer"
+            );
+          }
+        }
+      });
+    }
+  },
+
+  /**
+   * Try PUT for an app on the server and determine if we should retry
+   * if it fails.
+   */
+  _tryPuttingApp: function _tryPuttingApp(app, cb) {
+    let uri = this._makeAppURI(app.record.origin);
+    let req = new TokenAuthenticatedRESTRequest(uri, this.token);
+    if (app.modified) {
+      req.setHeader("X-If-Unmodified-Since", app.modified);
+    }
+
+    req.put(JSON.stringify(appRec), function _tryPuttingAppFinished(error) {
+      if (error) {
+        self._log.error("_tryPuttingApp request error " + error);
+        cb(error, null);
+        return;
+      }
+
+      let err = null;
+      switch (req.response.status) {
+        case 201:
+        case 204:
+          self._log.info("_tryPuttingApp succeeded");
+          cb(null, true);
+          break;
+
+        case 400:
+        case 412:
+        case 413:
+          let msg = "_tryPuttingApp returned: " + req.response.status;
+          self._log.warn(msg);
+          err = new Error(msg);
+          err.removeFromQueue = true;
+          cb(err, null);
+          break;
+
+        default:
+          self._error(req);
+          err = new Error("Unexpected error with _tryPuttingApp");
+          err.removeFromQueue = false;
+          cb(err, null);
+          break;
+      }
+    });
+  },
+
+  /**
+   * Fetch a manifest from given URL. No retries are made on failure.
+   */
+  _getManifest: function _getManifest(url, callback)  {
+    let req = new RESTRequest(url);
+    req.get(function(error) {
+      if (error) {
+        callback(error, null);
+        return;
+      }
+      if (!req.response.success) {
+        callback(new Error("Non-200 while fetching manifest"), null);
+        return;
+      }
+
+      let err = null;
+      let manifest = null;
+      try {
+        manifest = JSON.parse(req.response.body);
+        if (!manifest.name) {
+          self._log.warn(
+            "_getManifest got invalid manifest: " + req.response.body
+          );
+          err = new Error("Invalid manifest fetched");
+          manifest = null;
+        }
+      } catch (e) {
+        self._log.warn(
+          "_getManifest got invalid JSON response: " + req.response.body
+        );
+        err = new Error("Invalid manifest fetched");
+        manifest = null;
+      }
+
+      callback(err, manifest);
+    });
+  },
+
+  /**
+   * Determines what changes are to be made locally, given a list of local
+   * and remote apps.
+   */
+  _processApps: function _processApps(remoteApps, lApps, callback) {
+    let toDelete = {};
+    let localApps = {};
+    
+    // Convert lApps to a dictionary of origin -> app (instead of id -> app)
+    for (let [id, app] in Iterator(localApps)) {
+      app.id = id;
+      toDelete[app.origin] = app;
+      localApps[app.origin] = app;
+    }
+
+
+    // Iterate over remote apps, and find out what changes we must apply.
+    let toInstall = [];
+    for each (let app in remoteApps) {
+      // Don't delete apps that are both local & remote.
+      let origin = app.origin;
+      delete toDelete[origin];
+
+      // If there is a remote app that isn't local or 
+      // if the remote app was installed later
+      if ((!(origin in localApps)) ||
+           localApps[origin].installTime < app.installTime) {
+        
+        let id = localApps[origin].id || DOMApplicationRegistry.makeAppId();
+
+        // We should install this app locally
+        try {          
+          let record = {id: id, value: this._makeLocalApp(app)};
+          toInstall.push(record);
+        } catch (e) {
+          // App was an invalid record
+          this._log.error("A remote app was found to be invalid " + e);
+        }
+      }
+    }
+
+    // Uninstalls only need the ID & deleted flag
+    let toUninstall = [];
+    for (let origin in toDelete) {
+      toUninstall.push({id: toDelete[origin].id, deleted: true});
+    }
+
+    // Apply installs & uninstalls
+    this._applyUpdates(toInstall, toUninstall, callback);
+    return;
+  },
+
+  /**
+   * Applies a list of commands as determined by _processApps locally
+   */
+  _applyUpdates: function _applyUpdates(toInstall, toUninstall, callback) {
+    let finalCommands = [];
+    let toUpdate = toInstall.length;
+
+    let self = this;
+    function onManifestsUpdated() {
+      finalCommands.push(toUninstall);
+      if (finalCommands.length) {
+        self._log.info(
+          "processUpdates finished fetching manifests, calling updateApps"
+        );
+        DOMApplicationRegistry.updateApps(finalCommands, callback);
+      } else {
+        self._log.info(
+          "processUpdates finished fetching, no finalCommands were found"
+        );
+        callback();
+      }
+    }
+
+    // Update manifests for all the new remote apps we have.
+    let done = 0;
+    for (let j = 0; j < toUpdate; j++) {
+      let app = toInstall[j];
+      let url = app.value.manifestURL;
+      if (url[0] == "/") {
+        url = app.value.origin + app.value.manifestURL;
+      }
+
+      this._log.info("Updating manifest " + url + "\n");
+      this._getManifest(url, function(err, manifest) {
+        if (!err) {
+          app.value.manifest = manifest;
+          finalCommands.push({id: app.id, value: app.value});
+          self._log.info(app.id + " was added to finalCommands");
+        } else {
+          self._log.debug("Couldn't fetch manifest at " + url + ": " + err);
+        }
+
+        // Not a big deal if we couldn't get a manifest, we will try to fetch
+        // it again on the next checkServer. Carry on.
+        done += 1;
+        if (done == toUpdate) {
+          onManifestsUpdated();
+        }
+      });
+    }
+  }
+
+};
\ No newline at end of file
diff --git a/services/aitc/modules/main.js b/services/aitc/modules/main.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/modules/main.js
@@ -0,0 +1,364 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["Aitc"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/Webapps.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/identity/browserid.js");
+
+Cu.import("resource://services-aitc/client.js");
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-common/tokenserverclient.js");
+
+function AitcSvc() {
+  this._log = Log4Moz.repository.getLogger("Service.AITC");
+  this._log.level = Log4Moz.Level[Preferences.get(
+    "services.aitc.log.logger.service"
+  )];
+  let dapp = new Log4Moz.DumpAppender();
+  dapp.level = Log4Moz.Level["Info"];
+  this._log.addAppender(dapp);
+  this._log.info("Loading AitC");
+  this._manager = new AitcClientManager();
+}
+AitcSvc.prototype = {
+  get DASHBOARD() {
+    return Preferences.get("services.aitc.dashboard.url");
+  },
+
+  // The goal of the init function is to be ready to activate the AITC
+  // client whenever the user is looking at the dashboard
+  init: function init() {
+    let self = this;
+
+    // This is called iff the user is currently looking the dashboard
+    function dashboardLoaded(browser) {
+      self._log.info("Dashboard was accessed");
+      self._manager.userOnDashboard(browser.contentWindow);
+    }
+    // This is called when the user's attention is elsewhere
+    function dashboardUnloaded() {
+      self._log.info("Dashboard closed or in background");
+      self._manager.userOffDashboard();
+    }
+
+    // Called when a URI is loaded in any tab. We have to listen for this
+    // because tabSelected is not called if I open a new tab which loads
+    // about:home and then navigate to the dashboard, or navigation via
+    // links on the currently open tab
+    let listener = {
+      onLocationChange: function onLocationChange(browser, progress, req, location, flags) {
+        let win = Services.wm.getMostRecentWindow("navigator:browser");
+        if (win.gBrowser.selectedBrowser == browser) {
+          let uri = location.spec.substring(0, self.DASHBOARD.length);
+          if (uri == self.DASHBOARD) {
+            dashboardLoaded(browser);
+          }
+        }
+      }
+    };
+    // Called when the current tab selection changes
+    function tabSelected(event) {
+      let browser = event.target.linkedBrowser;
+      let uri = browser.currentURI.spec.substring(0, self.DASHBOARD.length);
+      if (uri == self.DASHBOARD) {
+        dashboardLoaded(browser);
+      } else {
+        dashboardUnloaded();
+      }
+    }
+
+    // Add listeners for all windows opened in the future
+    function winWatcher(subject, topic) {
+      if (topic != "domwindowopened") return;
+      subject.addEventListener("load", function winWatcherLoad() {
+        subject.removeEventListener("load", winWatcherLoad, false);
+        let doc = subject.document.documentElement;
+        if (doc.getAttribute("windowtype") == "navigator:browser") {
+          let browser = subject.gBrowser;
+          browser.addTabsProgressListener(listener);
+          browser.tabContainer.addEventListener("TabSelect", tabSelected);
+        }
+      }, false);
+    }
+    Services.ww.registerNotification(winWatcher);
+
+    // Add listeners for all current open windows
+    let enumerator = Services.wm.getEnumerator("navigator:browser");
+    while (enumerator.hasMoreElements()) {
+      let browser = enumerator.getNext().gBrowser;
+      browser.addTabsProgressListener(listener);
+      browser.tabContainer.addEventListener("TabSelect", tabSelected);
+
+      // Also check the currently open URI
+      let uri = browser.contentDocument.location.toString().substring(
+        0, self.DASHBOARD.length
+      );
+      if (uri == self.DASHBOARD) {
+        dashboardLoaded(browser);
+      }
+    }
+
+    // Add listeners for app installs/uninstall
+    Services.obs.addObserver(this, "webapps-sync-install", false);
+    Services.obs.addObserver(this, "webapps-sync-uninstall", false);
+  },
+
+  observe: function(aSubject, aTopic, aData) {
+    let app;
+    switch (aTopic) {
+      case "webapps-sync-install":
+        app = JSON.parse(aData);
+        this._log.info(app.origin + " was installed, initiating PUT");
+        this._manager.appEvent("install", app);
+        break;
+      case "webapps-sync-uninstall":
+        app = JSON.parse(aData);
+        this._log.info(app.origin + " was uninstalled, initiating PUT");
+        this._manager.appEvent("uninstall", app);
+        break;
+    }
+  }
+};
+
+function AitcClientManager() {
+  this._timer = null,
+  this._client = null;
+  this._log = Log4Moz.repository.getLogger("Service.AITC.Manager");
+  this._log.level = Log4Moz.Level[Preferences.get(
+    "services.aitc.log.logger.service"
+  )];
+  let dapp = new Log4Moz.DumpAppender();
+  dapp.level = Log4Moz.Level["Info"];
+  this._log.addAppender(dapp);
+  this._pending = {"install": [], "uninstall": []};
+}
+AitcClientManager.prototype = {
+  get MARKETPLACE() {
+    return Preferences.get("services.aitc.marketplace.url");
+  },
+
+  get TOKEN_SERVER() {
+    return Preferences.get("services.aitc.tokenServer.url");
+  },
+
+  /**
+   * Local app was just installed or uninstalled, ask client to PUT if user
+   * is logged in.
+   */
+  appEvent: function appEvent(type, app) {
+    if (this._client) {
+      this._doAppEvent(type, app);
+    }
+
+    // Silent client creation
+    let self = this;
+    this._makeClient(function(err, client) {
+      if (!err && client) {
+        self._client = client;
+        self._doAppEvent(type, app);
+      } else {
+        // Put in pending list and try later
+        self._pending[type].push(app);
+      }
+    });
+  },
+
+  /**
+   * User is looking at dashboard. Start polling, if user isn't logged in,
+   * prompt for one.
+   */
+  userOnDashboard: function userOnDashboard(win) {
+    if (this._client) {
+      this._startPoll();
+      return;
+    }
+
+    let self = this;
+    this._makeClient(function(err, client) {
+      if (err) {
+        // TODO: Surface this error the user, somehow
+        self._log.error("Client not created at Dashboard");
+        return;
+      }
+      self._client = client;
+      self._startPoll();
+    }, true, win);
+  },
+
+  /**
+   * User is not on the dashboard, we may stop polling (though PUTs will
+   * still continue in AitcClient).
+   */
+  userOffDashboard: function userOffDashboard() {
+    if (this._client) {
+      this._stopPoll();
+      return;
+    }
+  },
+  
+  /**
+   * Poll the AITC server for any changes and process them. Call this whenever
+   * the user is actively looking at the apps dashboard. It is safe to call
+   * this function multiple times.
+   */
+  _startPoll: function _startPoll() {
+    if (!this._client) {
+      throw new Error("_startPoll called without client");
+    }
+    if (this._timer) {
+      return;
+    }
+
+    // XXX: If pending, process those first.
+
+    // Do one GET check right now.
+    this._client.checkServer();
+
+    // And then once every FREQ seconds.
+    // TODO: Honor backoff values when we poll.
+    this._timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+
+    let self = this;
+    let event = {
+      notify: function notify(timer) {
+        self._client.checkServer();
+      }
+    };
+
+    this._timer.initWithCallback(event, FREQ, Ci.nsITimer.TYPE_REPEATING_SLACK);
+  },
+
+  /**
+   * Stop polling for changes. Call this as soon as the user
+   * isn't looking at the apps dashboard anymore. It is safe to call
+   * this function even if runPeriodically() wasn't called before.
+   */
+  _stopPoll: function _stopPoll() {
+    if (!this._timer) {
+      return;
+    }
+    this._timer.cancel();
+    this._timer = null;
+  },
+
+  /**
+   * Perform a remote install or uninstall.
+   */
+  _doAppEvent: function _doAppEvent(type, app) {
+    if (!this._client) {
+      throw "_doAppEvent called without client";
+    }
+    switch (type) {
+      case "install":
+        this._client.remoteInstall(app); break;
+      case "uninstall":
+        this._client.remoteUninstall(app); break;
+    }
+  },
+
+  /* Obtain a token from Sagrada token server, given a BrowserID assertion
+   * cb(err, token) will be invoked on success or failure.
+   */
+  _getToken: function _getToken(assertion, cb) {
+    let url = this.TOKEN_SERVER + "/1.0/aitc/1.0";
+    let client = new TokenServerClient();
+
+    let self = this;
+    this._log.info("Obtaining token from " + url);
+    client.getTokenFromBrowserIDAssertion(url, assertion, function(err, tok) {
+      if (!err) {
+        self._log.info("Got token from server: " + JSON.stringify(tok));
+        cb(null, tok);
+        return;
+      }
+
+      if (!err.response) {
+        let msg = "Error while fetching token " + err.message;
+        self._log.error(msg);
+        cb(new Error(msg), null);
+        return;
+      }
+      if (!err.response.success) {
+        let msg = "Error while fetching token (non-200) " + err.message;
+        self._log.error(msg);
+        cb(new Error(msg), null);
+        return;
+      }
+
+      let msg = "Unknown error while fetching token " + err.message;
+      self._log.error(msg);
+      cb(new Error(msg), null);
+    });
+  },
+
+  /* To start the AitcClient we need a token, for which we need a BrowserID
+   * assertion. If login is true, makeClient will ask the user to login in
+   * the context of win. cb is called with (err, client).
+   */
+  _makeClient: function makeClient(cb, login, win) {
+    if (!cb) {
+      throw new Error("makeClient called without callback");
+    }
+    if (login && !win) {
+      throw new Error("makeClient called with login as true but no win");
+    }
+
+    if (this._client) {
+      let msg = "Client already exists, not creating";
+      self._log.info(msg);
+      cb(new Error(msg), null);
+      return;
+    }
+
+    let self = this;
+    function processAssertion(val) {
+      self._log.info("Got assertion from BrowserID, creating token");
+      self._getToken(val, function(err, token) {
+        if (err) {
+          self._log.error("Could not obtain token from token server " + err);
+          cb(err, null);
+          return;
+        }
+        cb(null, new AitcClient(token));
+      });
+    }
+    function gotSilentAssertion(err, val) {
+      self._log.info("gotSilentAssertion called");
+      if (err) {
+        // If we were asked to let the user login, do the popup method
+        if (login) {
+          self._log.info("Could not obtain silent assertion, retrying login");
+          BrowserID.getAssertion(function gotAssertion(err, val) {
+            if (err) {
+              self._log.error("Could not obtain assertion even with login");
+              cb(err, false);
+              return;
+            }
+            processAssertion(val);
+          }, {}, win);
+          return;
+        }
+        self._log.error("Could not obtain assertion in _makeClient");
+        cb(err, false);
+      } else {
+        processAssertion(val);
+      }
+    }
+
+    // Check if we can get assertion silently first
+    BrowserID.getAssertion(gotSilentAssertion, {sameEmailAs: this.MARKETPLACE});
+  }
+};
+
+XPCOMUtils.defineLazyGetter(this, "Aitc", function() {
+  return new AitcSvc();
+});
diff --git a/services/aitc/service.js b/services/aitc/service.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/service.js
@@ -0,0 +1,44 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/FileUtils.jsm");
+Cu.import("resource://services-common/log4moz.js");
+
+function AitcService() {
+  this.wrappedJSObject = this;
+}
+AitcService.prototype = {
+  classID: Components.ID("{a3d387ca-fd26-44ca-93be-adb5fda5a78d}"),
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
+                                         Ci.nsISupportsWeakReference]),
+
+  observe: function observe(subject, topic, data) {
+    switch (topic) {
+      case "app-startup":
+        let os = Cc["@mozilla.org/observer-service;1"].
+                 getService(Ci.nsIObserverService);
+        os.addObserver(this, "final-ui-startup", true);
+        break;
+      case "final-ui-startup":
+        // Start AITC service after 2000ms
+        this.timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+        this.timer.initWithCallback({
+          notify: function() {
+            Cu.import("resource://services-aitc/main.js");
+            Aitc.init();
+          }
+        }, 2000, Ci.nsITimer.TYPE_ONE_SHOT);
+        break;
+    }
+  }
+};
+
+const components = [AitcService];
+const NSGetFactory = XPCOMUtils.generateNSGetFactory(components);
\ No newline at end of file
diff --git a/services/aitc/services-aitc.js b/services/aitc/services-aitc.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/services-aitc.js
@@ -0,0 +1,13 @@
+pref("dom.mozApps.whitelist", "https://myapps.mozillalabs.com");
+
+pref("services.aitc.dashboard.url", "https://myapps.mozillalabs.com");
+pref("services.aitc.marketplace.url", "https://marketplace.mozilla.org");
+//pref("services.aitc.tokenServer.url", "http://dev-token.services.mozilla.com");
+//pref("services.aitc.tokenServer.url", "http://token2.reg.mtv1.dev.svc.mozilla.com");
+pref("services.aitc.tokenServer.url", "https://stage-token.services.mozilla.com");
+
+pref("services.aitc.client.putInterval", 10000);
+pref("services.aitc.client.getInterval", 10000);
+
+pref("services.aitc.client.log.level", "Debug");
+pref("services.aitc.service.log.level", "Debug");
\ No newline at end of file
diff --git a/services/aitc/tests/Makefile.in b/services/aitc/tests/Makefile.in
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/Makefile.in
@@ -0,0 +1,16 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH     = ../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+relativesrcdir = services/aitc/tests
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = test_services_aitc
+XPCSHELL_TESTS = unit
+
+include $(topsrcdir)/config/rules.mk
diff --git a/services/aitc/tests/unit/test_load_modules.js b/services/aitc/tests/unit/test_load_modules.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/unit/test_load_modules.js
@@ -0,0 +1,11 @@
+const modules = [
+  "main.js",
+  "client.js",
+];
+
+function run_test() {
+  for each (let m in modules) {
+    _("Attempting to load resource://services-aitc/" + m);
+    Cu.import("resource://services-aitc/" + m, {});
+  }
+}
diff --git a/services/aitc/tests/unit/xpcshell.ini b/services/aitc/tests/unit/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/unit/xpcshell.ini
@@ -0,0 +1,6 @@
+[DEFAULT]
+head =
+tail =
+
+# Ensure we can import everything.
+[test_load_modules.js]
diff --git a/testing/xpcshell/xpcshell.ini b/testing/xpcshell/xpcshell.ini
--- a/testing/xpcshell/xpcshell.ini
+++ b/testing/xpcshell/xpcshell.ini
@@ -62,16 +62,17 @@ skip-if = os == "android"
 [include:extensions/cookie/test/unit/xpcshell.ini]
 [include:storage/test/unit/xpcshell.ini]
 [include:rdf/tests/unit/xpcshell.ini]
 [include:gfx/tests/unit/xpcshell.ini]
 [include:widget/tests/unit/xpcshell.ini]
 [include:content/base/test/unit/xpcshell.ini]
 [include:content/test/unit/xpcshell.ini]
 [include:toolkit/components/url-classifier/tests/unit/xpcshell.ini]
+[include:services/aitc/tests/unit/xpcshell.ini]
 [include:services/common/tests/unit/xpcshell.ini]
 [include:services/crypto/tests/unit/xpcshell.ini]
 [include:services/crypto/components/tests/unit/xpcshell.ini]
 [include:services/sync/tests/unit/xpcshell.ini]
 # Bug 676978: tests hang on Android 
 skip-if = os == "android"
 [include:browser/components/dirprovider/tests/unit/xpcshell.ini]
 [include:browser/components/downloads/test/unit/xpcshell.ini]
