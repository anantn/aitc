# HG changeset patch
# Parent 3eddb4087f85950c969eb9b567bc0f8777333f01
# User Anant Narayanan <anant@kix.in>
try: -b do -p all -u all -t all

diff --git a/services/common/rest.js b/services/common/rest.js
--- a/services/common/rest.js
+++ b/services/common/rest.js
@@ -143,16 +143,24 @@ RESTRequest.prototype = {
    * Request timeout (in seconds, though decimal values can be used for
    * up to millisecond granularity.)
    *
    * 0 for no timeout.
    */
   timeout: null,
 
   /**
+   * The encoding with which the response to this request must be treated.
+   * If a charset parameter is available in the HTTP Content-Type header for
+   * this response, that will always be used, and this value is ignored. We
+   * default to UTF-8.
+   */
+  charset: "utf-8",
+
+  /**
    * Called when the request has been completed, including failures and
    * timeouts.
    *
    * @param error
    *        Error that occurred while making the request, null if there
    *        was no error.
    */
   onComplete: function onComplete(error) {
@@ -305,16 +313,20 @@ RESTRequest.prototype = {
       let type = headers["content-type"] || "text/plain";
       channel.QueryInterface(Ci.nsIUploadChannel);
       channel.setUploadStream(stream, type, data.length);
     }
     // We must set this after setting the upload stream, otherwise it
     // will always be 'PUT'. Yeah, I know.
     channel.requestMethod = method;
 
+    // Before opening the channel, set the charset that serves as a hint
+    // as to what the response might be encoded as.
+    channel.contentCharset = this.charset;
+
     // Blast off!
     channel.asyncOpen(this, null);
     this.status = this.SENT;
     this.delayTimeout();
     return this;
   },
 
   /**
@@ -364,28 +376,18 @@ RESTRequest.prototype = {
     this._log.trace("onStartRequest: " + channel.requestMethod + " " +
                     channel.URI.spec);
 
     // Create a response object and fill it with some data.
     let response = this.response = new RESTResponse();
     response.request = this;
     response.body = "";
 
-    // Define this here so that we don't have make a new one each time
-    // onDataAvailable() gets called. If the Content-Type specified a charset,
-    // make sure we use the correct converter stream, instead of a generic
-    // ScriptableInputStream (onDataAvailable will pick the right one).
-    if (channel.contentCharset) {
-      response.charset = channel.contentCharset;
-      this._converterStream = Cc["@mozilla.org/intl/converter-input-stream;1"]
-                                .createInstance(Ci.nsIConverterInputStream);
-    } else {
-      this._inputStream = Cc["@mozilla.org/scriptableinputstream;1"]
-                          .createInstance(Ci.nsIScriptableInputStream);
-    }
+    this._converterStream = Cc["@mozilla.org/intl/converter-input-stream;1"]
+                            .createInstance(Ci.nsIConverterInputStream);
     this.delayTimeout();
   },
 
   onStopRequest: function onStopRequest(channel, context, statusCode) {
     if (this.timeoutTimer) {
       // Clear the abort timer now that the channel is done.
       this.timeoutTimer.clear();
     }
@@ -437,30 +439,27 @@ RESTRequest.prototype = {
 
     delete this._inputStream;
 
     this.onComplete(null);
     this.onComplete = this.onProgress = null;
   },
 
   onDataAvailable: function onDataAvailable(req, cb, stream, off, count) {
+    // response.charset should always be set to a value, since we provided a
+    // hint at dispatch.
     try {
-      if (this._inputStream) {
-        this._inputStream.init(stream);
-        this.response.body += this._inputStream.read(count);
-      } else {
-        let str = {};
-        this._converterStream.init(
-          stream, this.response.charset, 0,
-          this._converterStream.DEFAULT_REPLACEMENT_CHARACTER
-        );
-        let num = this._converterStream.readString(count, str);
-        if (num != 0) {
-          this.response.body += str.value;
-        }
+      let str = {};
+      this._converterStream.init(
+        stream, this.response.charset, 0,
+        this._converterStream.DEFAULT_REPLACEMENT_CHARACTER
+      );
+      let num = this._converterStream.readString(count, str);
+      if (num != 0) {
+        this.response.body += str.value;
       }
     } catch (ex) {
       this._log.warn("Exception thrown reading " + count +
                      " bytes from the channel.");
       this._log.debug(CommonUtils.exceptionStr(ex));
       throw ex;
     }
 
diff --git a/services/common/tests/unit/test_restrequest.js b/services/common/tests/unit/test_restrequest.js
--- a/services/common/tests/unit/test_restrequest.js
+++ b/services/common/tests/unit/test_restrequest.js
@@ -159,37 +159,130 @@ add_test(function test_get() {
   });
 });
 
 /**
  * Test HTTP GET with UTF-8 content, and custom Content-Type.
  */
 add_test(function test_get_utf8() {
   let response = "Hello World or Καλημέρα κόσμε or こんにちは 世界";
-  let contentType = "text/plain; charset=UTF-8";
+
+  let contentType = "text/plain";
+  let charset = true;
+  let charsetSuffix = "; charset=UTF-8";
 
   let server = httpd_setup({"/resource": function(req, res) {
     res.setStatusLine(req.httpVersion, 200, "OK");
-    res.setHeader("Content-Type", contentType);
+    res.setHeader("Content-Type", contentType + (charset ? charsetSuffix : ""));
 
     let converter = Cc["@mozilla.org/intl/converter-output-stream;1"]
                     .createInstance(Ci.nsIConverterOutputStream);
     converter.init(res.bodyOutputStream, "UTF-8", 0, 0x0000);
     converter.writeString(response);
     converter.close();
   }});
 
+  // Check if charset in Content-Type is propertly interpreted.
+  let request1 = new RESTRequest(TEST_RESOURCE_URL);
+  request1.get(function(error) {
+    do_check_null(error);
+
+    do_check_eq(request1.response.status, 200);
+    do_check_eq(request1.response.body, response);
+    do_check_eq(request1.response.headers["content-type"],
+                contentType + charsetSuffix);
+
+    // Check that we default to UTF-8 if Content-Type doesn't have a charset.
+    charset = false;
+    let request2 = new RESTRequest(TEST_RESOURCE_URL);
+    request2.get(function(error) {
+      do_check_null(error);
+
+      do_check_eq(request2.response.status, 200);
+      do_check_eq(request2.response.body, response);
+      do_check_eq(request2.response.headers["content-type"], contentType);
+
+      server.stop(run_next_test);
+    });
+  });
+});
+
+/**
+ * Test more variations of charset handling.
+ */
+add_test(function test_charsets() {
+  let response = "Hello World, I can't speak Russian";
+
+  let contentType = "text/plain";
+  let charset = true;
+  let charsetSuffix = "; charset=us-ascii";
+
+  let server = httpd_setup({"/resource": function(req, res) {
+    res.setStatusLine(req.httpVersion, 200, "OK");
+    res.setHeader("Content-Type", contentType + (charset ? charsetSuffix : ""));
+
+    let converter = Cc["@mozilla.org/intl/converter-output-stream;1"]
+                    .createInstance(Ci.nsIConverterOutputStream);
+    converter.init(res.bodyOutputStream, "us-ascii", 0, 0x0000);
+    converter.writeString(response);
+    converter.close();
+  }});
+
+  // Check that provided charset overrides hint.
+  let request1 = new RESTRequest(TEST_RESOURCE_URL);
+  request1.charset = "not-a-charset";
+  request1.get(function(error) {
+    do_check_null(error);
+
+    do_check_eq(request1.response.status, 200);
+    do_check_eq(request1.response.body, response);
+    do_check_eq(request1.response.headers["content-type"],
+                contentType + charsetSuffix);
+
+    // Check that hint is used if Content-Type doesn't have a charset.
+    charset = false;
+    let request2 = new RESTRequest(TEST_RESOURCE_URL);
+    request2.charset = "us-ascii";
+    request2.get(function(error) {
+      do_check_null(error);
+
+      do_check_eq(request2.response.status, 200);
+      do_check_eq(request2.response.body, response);
+      do_check_eq(request2.response.headers["content-type"], contentType);
+
+      server.stop(run_next_test);
+    });
+  });
+});
+
+/**
+ * Test that responses are decoded with the charset in the provided hint if
+ * Content-Type doesn't specify one.
+ */
+add_test(function test_charsets_hint_conversion() {
+  let response = "Hello ☺ World";
+
+  let server = httpd_setup({"/resource": function(req, res) {
+    res.setStatusLine(req.httpVersion, 200, "OK");
+    res.setHeader("Content-Type", "text/plain");
+    let converter = Cc["@mozilla.org/intl/converter-output-stream;1"]
+                    .createInstance(Ci.nsIConverterOutputStream);
+    converter.init(res.bodyOutputStream, "utf-8", 0, 0x0000);
+    converter.writeString(response);
+    converter.close();
+  }});
+
   let request = new RESTRequest(TEST_RESOURCE_URL);
+  request.charset = "US-ASCII";
   request.get(function(error) {
-    do_check_eq(error, null);
-
+    do_check_null(error);
     do_check_eq(request.response.status, 200);
-    do_check_eq(request.response.body, response);
-    do_check_eq(request.response.headers["content-type"], contentType);
-
+    // Content should be decoded as US-ASCII, not UTF-8.
+    let unichar = String.fromCharCode(9786);
+    do_check_eq(request.response.body, "Hello " + unichar + " World");
     server.stop(run_next_test);
   });
 });
 
 /**
  * Test HTTP PUT with a simple string argument and default Content-Type.
  */
 add_test(function test_put() {
