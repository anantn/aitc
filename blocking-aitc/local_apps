# HG changeset patch
# Parent 9e5967a09ac10798c878381ff4ad40acbd327f05

diff --git a/dom/apps/src/Webapps.jsm b/dom/apps/src/Webapps.jsm
--- a/dom/apps/src/Webapps.jsm
+++ b/dom/apps/src/Webapps.jsm
@@ -193,17 +193,17 @@ let DOMApplicationRegistry = {
 
     let dir = FileUtils.getDir(DIRECTORY_NAME, ["webapps", id], true, true);
     let manFile = dir.clone();
     manFile.append("manifest.webapp");
     this._writeFile(manFile, JSON.stringify(app.manifest));
     this.webapps[id] = appObject;
 
     appObject.status = "installed";
-    
+
     let manifest = new DOMApplicationManifest(app.manifest, app.origin);
 
     if (!aFromSync)
       this._saveApps((function() {
         ppmm.sendAsyncMessage("Webapps:Install:Return:OK", aData);
         Services.obs.notifyObservers(this, "webapps-sync-install", appNote);
       }).bind(this));
 
@@ -367,17 +367,17 @@ let DOMApplicationRegistry = {
   /** Added to support AITC and classic sync */
   itemExists: function(aId) {
     return !!this.webapps[aId];
   },
 
   getAppById: function(aId) {
     if (!this.webapps[aId])
       return null;
-    
+
     let app = this._cloneAppObject(this.webapps[aId]);
     return app;
   },
 
   getAppByManifestURL: function(aManifestURL) {
     // This could be O(1) if |webapps| was a dictionary indexed on manifestURL
     // which should be the unique app identifier.
     // It's currently O(n).
@@ -385,17 +385,17 @@ let DOMApplicationRegistry = {
       let app = this.webapps[id];
       if (app.manifestURL == aManifestURL) {
         return this._cloneAppObject(app);
       }
     }
 
     return null;
   },
-  
+
   getAllWithoutManifests: function(aCallback) {
     let result = {};
     for (let id in this.webapps) {
       let app = this._cloneAppObject(this.webapps[id]);
       result[id] = app;
     }
     aCallback(result);
   },
diff --git a/services/aitc/modules/client.js b/services/aitc/modules/client.js
--- a/services/aitc/modules/client.js
+++ b/services/aitc/modules/client.js
@@ -176,17 +176,17 @@ AitcClient.prototype = {
       cb(new Error("Exception in getApps " + e), null);
       return;
     }
 
     // Return success.
     try {
       cb(null, apps);
       // Don't update lastModified until we know cb succeeded.
-      this._appsLastModified = parseInt(req.response.headers["X-Timestamp"], 10);
+      this._appsLastModified = parseInt(req.response.headers["x-timestamp"], 10);
       this._state.set("lastModified", ""  + this._appsLastModified);
     } catch (e) {
       this._log.error("Exception in getApps callback " + e);
     }
   },
 
   /**
    * Change a given app record to match what the server expects.
diff --git a/services/aitc/modules/main.js b/services/aitc/modules/main.js
--- a/services/aitc/modules/main.js
+++ b/services/aitc/modules/main.js
@@ -27,18 +27,19 @@ function Aitc() {
   this.DASHBOARD_ORIGIN = CommonUtils.makeURI(
     Preferences.get("services.aitc.dashboard.url")
   ).prePath;
 
   this._manager = new AitcManager(this._init.bind(this));
 }
 Aitc.prototype = {
   // The goal of the init function is to be ready to activate the AITC
-  // client whenever the user is looking at the dashboard.
-  _init: function init() {
+  // client whenever the user is looking at the dashboard. It also calls
+  // the init function on the manager.
+  _init: function _init() {
     let self = this;
 
     // This is called iff the user is currently looking the dashboard.
     function dashboardLoaded(browser) {
       let win = browser.contentWindow;
       self._log.info("Dashboard was accessed " + win);
 
       // If page is ready to go, fire immediately.
diff --git a/services/aitc/modules/manager.js b/services/aitc/modules/manager.js
--- a/services/aitc/modules/manager.js
+++ b/services/aitc/modules/manager.js
@@ -50,23 +50,18 @@ function AitcManager(cb) {
     // Inform the AitC service that we're good to go!
     self._log.info("AitC manager has finished loading");
     try {
       cb(true);
     } catch (e) {
       self._log.error(new Error("AitC manager callback threw " + e));
     }
 
-    // Schedule them, but only if we can get a silent assertion.
-    self._makeClient(function(err, client) {
-      if (!err && client) {
-        self._client = client;
-        self._processQueue();
-      }
-    }, false);
+    // Do intial PUT/GET on the next tick.
+    CommonUtils.nextTick(self._initialSchedule, self);
   });
 }
 AitcManager.prototype = {
   /**
    * State of the user. ACTIVE implies user is looking at the dashboard,
    * PASSIVE means either not at the dashboard or the idle timer started.
    */
   _ACTIVE: 1,
@@ -153,16 +148,69 @@ AitcManager.prototype = {
    * page, a call to userActive MUST be made.
    */
   userIdle: function userIdle() {
     this._state = this._PASSIVE;
     this._dashboardWindow = null;
   },
 
   /**
+   * Initial schedule for the manager. This will be called by the
+   * constructor after the queue has been initialized.
+   *
+   * Try to schedule PUTs but only if we can get a silent assertion, and if
+   * the queue in non-empty, or we've never done a GET (first run).
+   */
+  _initialSchedule: function _initialSchedule() {
+    let self = this;
+
+    function startProcessQueue() {
+      self._makeClient(function(err, client) {
+        if (!err && client) {
+          self._client = client;
+          self._processQueue();
+        }
+      });
+    }
+
+    if (Preferences.get("services.aitc.client.lastModified", "0") != "0") {
+      if (this._pending.length) {
+        startProcessQueue();
+      }
+      return;
+    }
+
+    DOMApplicationRegistry.getAllWithoutManifests(function gotAllApps(apps) {
+      let done = 0;
+      let appids = Object.keys(apps);
+      let total = appids.length;
+      self._log.info("First run, queuing all local apps: " + total + " found");
+
+      function appQueued(err) {
+        if (err) {
+          self._log.error("Error queuing app " + apps[appids[done]].origin);
+        }
+
+        if (done == total) {
+          self._log.info("Finished queuing all initial local apps");
+          startProcessQueue();
+          return;
+        }
+
+        let app = apps[appids[done]];
+        let obj = {type: "install", app: app, retries: 0, lastTime: 0};
+
+        done += 1;
+        self._pending.enqueue(obj, appQueued);
+      }
+      appQueued();
+    });
+  },
+
+  /**
    * Poll the AITC server for any changes and process them. It is safe to call
    * this function multiple times. Last caller wins. The function will
    * grab the current user state from _state and act accordingly.
    *
    * Invalid states will cause this function to throw.
    */
   _setPoll: function _setPoll() {
     if (this._state == this._ACTIVE && !this._client) {
@@ -180,17 +228,17 @@ AitcManager.prototype = {
 
     // Check if there are any PUTs pending first.
     if (this._pending.length && !(this._putTimer)) {
       // There are pending PUTs and no timer, so let's process them. GETs will
       // resume after the PUTs finish (see processQueue)
       this._processQueue();
       return;
     }
-    
+
     // Do one GET soon, but only if user is active.
     let getFreq;
     if (this._state == this._ACTIVE) {
       CommonUtils.nextTick(this._checkServer, this);
       getFreq = PREFS.get("manager.getActiveFreq");
     } else {
       getFreq = PREFS.get("manager.getPassiveFreq");
     }
@@ -426,24 +474,24 @@ AitcManager.prototype = {
         return;
       }
 
       // Silent refresh was asked for.
       if (!win) {
         cb(err, null);
         return;
       }
-      
+
       // Prompt user to login.
       self._makeClient(function(err, client) {
         if (err) {
           cb(err, null);
           return;
         }
-      
+
         // makeClient sets an updated token.
         self._client = client;
         cb(null, true);
       }, win);
     }
 
     let options = { audience: DASHBOARD_URL };
     if (this._lastEmail) {
diff --git a/services/aitc/modules/storage.js b/services/aitc/modules/storage.js
--- a/services/aitc/modules/storage.js
+++ b/services/aitc/modules/storage.js
@@ -327,17 +327,17 @@ AitcStorageImpl.prototype = {
     }
 
     // Apply uninstalls first, we do not need to fetch manifests.
     if (toUninstall.length) {
       this._log.info("Applying uninstalls to registry");
 
       let self = this;
       DOMApplicationRegistry.updateApps(toUninstall, function() {
-        // If there are installs, proceed to apply each on in parallel. 
+        // If there are installs, proceed to apply each one in parallel.
         if (toInstall.length) {
           self._applyInstalls(toInstall, callback);
           return;
         }
         callback();
       });
 
       return;
diff --git a/services/aitc/tests/unit/test_manager.js b/services/aitc/tests/unit/test_manager.js
new file mode 100644
--- /dev/null
+++ b/services/aitc/tests/unit/test_manager.js
@@ -0,0 +1,89 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+Cu.import("resource://gre/modules/Webapps.jsm");
+
+Cu.import("resource://services-aitc/manager.js");
+Cu.import("resource://services-common/utils.js");
+Cu.import("resource://services-common/preferences.js");
+
+let fakeApp1 = {
+  origin: "http://1.example.org",
+  receipts: [],
+  manifestURL: "/manifest.webapp",
+  installOrigin: "http://localhost",
+  installedAt: Date.now(),
+  modifiedAt: Date.now(),
+
+  manifest: {
+    name: "Appasaurus 1",
+    description: "One of the best fake apps ever",
+    launch_path: "/",
+    fullscreen: true,
+    required_features: ["webgl"]
+  }
+};
+
+let fakeApp2 = {
+  origin: "http://2.example.org",
+  receipts: [],
+  manifestURL: "/manifest.webapp",
+  installOrigin: "http://localhost",
+  installedAt: Date.now(),
+  modifiedAt: Date.now(),
+
+  manifest: {
+    name: "Appasaurus 2",
+    description: "The other best fake app ever",
+    launch_path: "/",
+    fullscreen: true,
+    required_features: ["geolocation"]
+  }
+};
+
+function run_test() {
+  run_next_test();
+}
+
+add_test(function test_manager_localapps() {
+  // Install two fake apps into the DOM registry.
+  DOMApplicationRegistry.confirmInstall({app: fakeApp1});
+  DOMApplicationRegistry.confirmInstall({app: fakeApp2});
+
+  // Create an instance of the manager and check if it put the app in the queue.
+  let manager = new AitcManager(function() {
+    // Here's where it gets ugly, the manager will add local apps to the queue
+    // asynchronously, so we don't know for sure when to check if the app was
+    // added. We'll wait for arbritrary 100ms (intermittent orange warning!).
+    let checkQueue = {
+      callback: function() {
+        do_check_eq(manager._pending.length, 2);
+        let entry = manager._pending.peek();
+        do_check_eq(entry.type, "install");
+        do_check_eq(entry.app.origin, fakeApp1.origin);
+
+        // Reset the queue, so the next test is clean.
+        manager._pending.dequeue(function() {
+          manager._pending.dequeue(run_next_test);
+        });
+      }
+    };
+    CommonUtils.namedTimer(checkQueue.callback, 100, checkQueue, "timer");
+  });
+});
+
+add_test(function test_manager_alreadysynced() {
+  // The manager should ignore any local apps if we've already synced before.
+  DOMApplicationRegistry.confirmInstall({app: fakeApp2});
+  Preferences.set("services.aitc.client.lastModified", "" + Date.now());
+
+  let manager = new AitcManager(function() {
+    let checkQueue = {
+      callback: function() {
+        do_check_eq(manager._pending.length, 0);
+        run_next_test();
+      }
+    };
+    CommonUtils.namedTimer(checkQueue.callback, 100, checkQueue, "timer");
+  });
+});
diff --git a/services/aitc/tests/unit/xpcshell.ini b/services/aitc/tests/unit/xpcshell.ini
--- a/services/aitc/tests/unit/xpcshell.ini
+++ b/services/aitc/tests/unit/xpcshell.ini
@@ -1,7 +1,8 @@
 [DEFAULT]
 head = ../../../common/tests/unit/head_global.js ../../../common/tests/unit/head_helpers.js
 tail =
 
 [test_load_modules.js]
+[test_manager.js]
 [test_storage_queue.js]
 [test_storage_registry.js]
